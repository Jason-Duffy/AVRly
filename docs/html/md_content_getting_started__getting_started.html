<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AVRly - AVR Development Resources: Getting Started with Blink</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">AVRly - AVR Development Resources
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_content_getting_started__getting_started.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Getting Started with Blink </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The projects outlined in this repository are intended for <a href="https://microcontrollerslab.com/difference-bare-metal-and-rtos-based-embedded-systems/" target="_blank">"bare metal"</a> AVR programming. That is - compiling, debugging and flashing your application without an underlying operating system, directly to the target MCU using the AVR toolchain and an ISP programmer, rather than using the simpler and more user-friendly (but somewhat limiting) Arduino framework.</p>
<p >The Blink example isn't a particularly groundbreaking project, but it serves to verify that the setup of your development environment and configuration of the target MCU have been performed correctly, before moving onto more complex projects and examples where issues could be harder to diagnose.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Software Requirements</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
A Source Code Editor</h2>
<p >I like <a href="http://www.sublimetext.com/" target="_blank">Sublime Text</a>, but there are plenty to choose from, some popular choices are:</p><ul>
<li><a href="http://www.sublimetext.com/" target="_blank">Sublime Text</a></li>
<li><a href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a></li>
<li><a href="https://github.com/features/codespaces" target="_blank">Codespaces</a></li>
<li><a href="https://github.com/features/codespaces" target="_blank">Atom</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
The AVR Toolchain</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
MacOS</h3>
<p ><a href="https://www.obdev.at/products/crosspack/index.html" target="_blank">AVR CrossPack</a> will provide everything you need to develop for AVR on MacOS; the GNU compile suite, C libraries for the AVR, the AVRDUDE uploader and more. </p>
<h3><a class="anchor" id="autotoc_md5"></a>
Linux</h3>
<h4><a class="anchor" id="autotoc_md6"></a>
Debian/Ubuntu distributions</h4>
<ul>
<li><p class="startli">It's helpful to update all your current installed packages first.</p>
<p class="startli"><code>sudo apt-get update</code></p>
<p class="startli"><code>sudo apt-get upgrade all</code></p>
</li>
<li><p class="startli">Then we can install the required packages.</p>
<p class="startli"><code>sudo apt-get install avrdude avrdude-doc gcc-avr binutils-avr avr-libc gdb-avr</code></p>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md7"></a>
Red Hat and Fedora distributions</h4>
<ul>
<li><p class="startli">It's helpful to update all your current installed packages first.</p>
<p class="startli"><code>sudo yum update</code></p>
<p class="startli"><code>sudo yum upgrade-all</code></p>
</li>
<li><p class="startli">Then we can install the required packages.</p>
<p class="startli"><code>sudo yum install avrdude avr-gcc avr-binutils avr-libc avr-gdb</code></p>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md8"></a>
Windows</h3>
<p >Windows users can use the official toolchain from the manufacturer, <a href="https://www.microchip.com/en-us/tools-resources/develop/microchip-studio" target="_blank">Microchip Studio</a> (formerly ATmel). This is an IDE so it's full of features, but also has a relatively steep learning curve - follow their tutorial <a href="https://www.microchip.com/en-us/tools-resources/develop/microchip-studio#Getting%20Started" target="_blank">here</a> to get to grips with it.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
A Serial Terminal Program</h2>
<p >This is used later in the more advanced modules to send messages between your PC and the target MCU. You'll find it's a vital debugging tool when coupled with the log_system module. I tend to use <a href="https://freeware.the-meiers.org/" target="_blank">CoolTerm</a> which is available for free on MacOS, Windows and Linux.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
Hardware Required</h1>
<h2><a class="anchor" id="autotoc_md11"></a>
An AVR microcontroller</h2>
<p >An <a href="https://www.amazon.co.uk/Atmel-ATMega328-PU-ATMEL-Microcontroller-Chip/dp/B071Y4YF5X/ref=sr_1_5?crid=564N7F4OE3JE&amp;keywords=atmega328&amp;qid=1647299808&amp;sprefix=atmega328%2Caps%2C62&amp;sr=8-5" target="_blank">ATmega328P-PU</a> is a good place to start - It's a DIP package so fits nicely in a breadboard or an IC socket, has a whopping 32KB of flash memory (ok it's not much but you can do a surprising amount with that), and 3 GPIO ports. This chip is ubiquitous so you'll have no problem finding hardware to support it - it's actually the MCU the Arduino Uno is built around.</p>
<p >It's worth noting that the ATmega328P now has a status of "Not recommended for new designs" meaning the model is being gradually phased out in favour of the newer ATmega328PB. Code written for the 328P will still work fine on the 328PB thanks to backwards compatability, but it is <b>not</b> a drop-in replacement, so the pinout will be different. For more info on the differences betwenn the two, see application note <a href="http://atmel-studio-doc.s3-website-us-east-1.amazonaws.com/webhelp/GUID-CBDC1838-0100-4F26-A45A-134958193C3B-en-US-3/index.html?GUID-2A0D6256-07A2-49A1-B57E-B94459515300" target="_blank">AT15007</a>. Most of the examples in this repository will be using the ATmega328P, and it is strongly advised to refer to it's <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">datasheet</a> if you are unsure about anything along the way.</p>
<p >Whilst the <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">datasheet</a> may be overwhelming at first, it's best to get used to referring to it as you go. It's also worth pointing out at this stage that you aren't expected to read it cover to cover as if it were a novel. Use the index menu in your PDF browser to home in on the chapter or section that sounds like it might be most relevant to the register or peripheral you're working on.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
An ISP Programmer</h2>
<p >Such as an <a href="https://www.amazon.co.uk/Waveshare-Programmer-USB-AVRISP-XPII/dp/B00KM6ZA9I?th=1" target="_blank">AVRISP MKII</a>, however that model is not compattible with MacOS, so instead I use an Arduino Uno with the "Arduino as ISP" sketch flashed to it, and <a href="https://github.com/Jason-Duffy/AVRly/tree/main/content/getting-started/Uno_ISP_Shield" target="_blank">a simple shield I made</a> - though you can achieve the same thing with some dupont cables if you don't want to wait for the shield to come back from fab. The Arduino as ISP sketch can be found in the Arduino IDE. <img src="arduino_isp_shield.jpg" alt="" class="inline" title="Arduino ISP Shield"/>    </p>
<h2><a class="anchor" id="autotoc_md13"></a>
A USB to Serial Converter</h2>
<p >There are many types available, I use one of <a href="https://www.amazon.co.uk/Ccylez-Converter-Adapter-FT232RL-Android-default/dp/B08DV1SXMQ/ref=sr_1_4?crid=8ZN3WET67TSU&amp;keywords=usb+serial+converter+module&amp;qid=1647296288&amp;sprefix=usb+serial+converter+modul%2Caps%2C72&amp;sr=8-4" target="_blank">these</a>. Not required for the Blink example but useful for the log_system module and debugging your projects.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Various USB cables</h2>
<p >It's useful to keep several USB cables, micro, mini, USB-A etc.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Breadboards</h2>
<p >I like <a href="https://www.amazon.co.uk/AZDelivery-Breadboard-Supply-Adapter-Jumkper/dp/B01N4VCYUK/ref=sr_1_20?crid=29EM44FS19IF2&amp;keywords=breadboard%2Bwith%2Bpower%2Bsupply&amp;qid=1647296608&amp;sprefix=breadboard%2Bwith%2Bpower%2Bsupply%2Caps%2C64&amp;sr=8-20&amp;th=1" target="_blank">these</a> ones with the power supply module for small test projects, and <a href="https://www.amazon.co.uk/K-H-RH-74-Solderless-Breadboard/dp/B079H4N8Y4/ref=sr_1_6?crid=18JXJAV0E8H6K&amp;keywords=large+breadboard+electronics&amp;qid=1647296861&amp;sprefix=large+breadboard+electronics%2Caps%2C56&amp;sr=8-6" target="_blank">these</a> ones for larger, more complex projects. For anything beyond that, I would design a development PCB with lots of connection and expansion flexibility.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Power Supply (optional)</h2>
<p >Most ISP programmers will provide a 5V power line for your MCU, however this is likely sourced from your PC's USB port, and there are a few things to be aware of here. First, most USB ports can only source upto 500mA, so if your project is likely to come close to or surpass that limit, you wil need to provide an external power supply capable of sourcing that much current. Also note the GPIO's on the AVR aren't able to source (or sink) much current, 40mA is the upper limit, so further driver circuitry will be needed to drive larger loads.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Jumpers/Dupont cables</h2>
<p >A set of <a href="https://www.amazon.co.uk/WANTOUTH-Preformed-Breadboard-Solderless-Prototyping/dp/B08QS6961R/ref=sr_1_5?crid=36KPWIVO59605&amp;keywords=breadboard+jumpers&amp;qid=1647300367&amp;sprefix=breadboard+jumpers%2Caps%2C245&amp;sr=8-5" target="_blank">breadboard jumper cables</a> is handy to keep your close wiring neat and tidy, then a set of various lengths and connection types of <a href="https://www.amazon.co.uk/YXPCARS-Solderless-Breadboard-Multicolored-Arduino/dp/B08HQ7K6M7/ref=sr_1_27?crid=1GQC7DDTANB5H&amp;keywords=dupont+cables+set&amp;qid=1647301269&amp;sprefix=dupont+cables+set%2Caps%2C71&amp;sr=8-27" target="_blank">dupont cables</a> is useful to connect to other peripherals.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
An assortment of components</h2>
<p >A kit like <a href="https://www.amazon.co.uk/Freenove-Ultimate-Compatible-Programming-Electronics/dp/B08B4D5MV5/ref=sr_1_17_sspa?crid=YI7I2MN0COCC&amp;keywords=arduino+components+kit&amp;qid=1647301388&amp;sprefix=arduino+components%2Caps%2C75&amp;sr=8-17-spons&amp;psc=1&amp;spLa=ZW5jcnlwdGVkUXVhbGlmaWVyPUEzTjY0QVFGTEZHREVNJmVuY3J5cHRlZElkPUEwNjU1Mzk4MkRCS1c5UFBaMUI2QiZlbmNyeXB0ZWRBZElkPUEwMDEyMzQxM1NSUDZWS1RPM1Q2SCZ3aWRnZXROYW1lPXNwX210ZiZhY3Rpb249Y2xpY2tSZWRpcmVjdCZkb05vdExvZ0NsaWNrPXRydWU=" target="_blank">this one</a> is a frugal way to source many of the components and accessories needed - plus some extras which might come in handy along the way. You will certainly need a selection of resistors, capacitors, LEDs etc.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
A multimeter</h2>
<p >A multimeter like <a href="https://www.ebay.co.uk/itm/373974464011?epid=23040427421&amp;_trkparms=ispr%3D1&amp;hash=item57129d760b:g:ecgAAOSwcvJhM~1Y&amp;amdata=enc%3AAQAGAAACoPYe5NmHp%252B2JMhMi7yxGiTJkPrKr5t53CooMSQt2orsSafTQYbq3L7RBVAMi0K9cw1RWXBpCryIDtHtQ%252FwGGrM5qNRo2BcdEvJNXURbFcGIieFzIjcYyayBhlA94swn2TTvs028l2IF1Z7kkPlAkTOZau7i64BOsAJM5jtEUKTzYuTAksI%252B6wqVDHXCmc%252BbqVJWdWCtN%252FedfWrLz22fV7JfFf3r%252BndQy6pgUf%252B0CqyxVpLGK%252FtsA2WoJN66265Nsb%252Biz2cPGbaMohOx96MSBAMI556eVyZ1Jt%252FgLkiIOgy%252F4LEQX%252B3foG6Ptb%252BN9ZmnQkdg5oCnRE0hxlFfAD5SOzEzmtg9%252BIE2HDfbFvLsU0Z0%252BZ2IQwJohjr5c6NdN3ax%252B0NkAFl5TKriVBAerlTCklJ%252BeOmn4DGytxPaRs%252B7VYCtZf8PXhxRmWn89GJw9Xt%252FCGpH1hvp9DXVNVCjJBMZeRVIKV3LmmgTdNnj9a%252FAUNwyB5qnSZWNkYEvX0swcp0PJU6qoVXYAEBLx2T03VucnyJ6R8Ja2NbFUVIPLPL4f4hHTUcR5hxbe0v9ux4iwgbiJLIPIXDKfDovdqX%252BUgBKJiLOUzGZKey7I7PeEDHsw5vr1KEHBd6%252B3Cw0FN0asmNY2XUmwd9LrLf401Wo4ovba%252FjznpyXfGfjHaobMVxQzN%252FAPIdxhcaODHy%252Bku4xgVEgZaD8n58JPn%252Fz0u75IwCzYoV%252FHGCX7zUgjd0Flsw5CiQpHVdB4eqGaKKP97ct2rRUEtd4t5YZJJi7KbHlJxs3Kr4KxuyQ2Xfk4nbZhpRPStSf%252FrLNa%252FxQudCxW2vnABZJayi8xGYlqFq%252BZYczELbh3%252BIyYls%252FmPtJgL%252F0yOiQgmVnId%252BTVMf1Q7taqp1w%252FN0AaMA%253D%253D%7Cclp%3A2334524%7Ctkp%3ABFBMlsihrvFf" target="_blank">this one</a> will help with debugging when hardware is involved. An <a href="https://telonic.co.uk/product/rigol-ds1054z-50mhz-digital-oscilloscope/" target="_blank">oscilloscope</a> gives an extra dimension of insight into your circuits and applications, but they are an expensive piece of kit so a little out of reach for beginners.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Connecting the Hardware</h1>
<p >The following setup guide is for an ATmega328P, so if you're starting with a different model it's best to refer to your part's datasheet for pinout, auxillary components needed, power requirements etc, but the broad principles should be much the same.</p>
<p >The pinout of the ATmega328P is shown below.</p>
<div class="image">
<img src="ATmega328P-pinout.webp" alt=""/>
<div class="caption">
ATmega328P pinout</div></div>
    <h2><a class="anchor" id="autotoc_md21"></a>
MCU Connections</h2>
<p >Note the 100nF ceramic capacitor between VCC and GND, this is for decoupling and filtering of the power supply, so should be placed as close to the pins as possible. <img src="decoupling_cap.png" alt="" class="inline" title="Decoupling capacitor"/>    </p>
<p >You can use the MCU with just it's internal oscillator as a clock source (8MHz or 1MHz depending on configuration), or if you'd prefer a faster clock speed you can use an external crystal oscillator upto 20MHz. Refer to your chip's datasheet and application notes for details on oscillator circuit design.</p>
<p >Connect a GPIO pin (PB0 in this example) to an LED, with a 220Î© resistor in series with the anode, and the cathode to ground.</p>
<div class="image">
<img src="led_connection.png" alt=""/>
<div class="caption">
LED Connection</div></div>
    <h2><a class="anchor" id="autotoc_md22"></a>
Programmer Connections</h2>
<p >The IDC connector on your ISP programmer should be connected to the target MCU as shown in the images below. The schematic symbols on the left depict the end of the IDC connector - Note the notch on the right hand side - if you turn the connector to face you and rotate it so the notch is on the right, your orientation will be correct.</p>
<div class="image">
<img src="idc_connector_orientation.jpg" alt=""/>
<div class="caption">
IDC connector orientation</div></div>
    <div class="image">
<img src="isp_header_pinout.png" alt=""/>
<div class="caption">
ISP programmer connections</div></div>
    <p >If you're using an Arduino Uno as an ISP with some dupont cables, then you can make the connections between that and the target MCU as per the schematic below.</p>
<div class="image">
<img src="arduino_isp_hookup.png" alt=""/>
<div class="caption">
Arduino as ISP connections</div></div>
    <p >Connect the programmer to your PC, then check which serial port it's on. If you have the Arduino IDE, you can go to Tools &gt; Port &gt; <em>port address is shown here</em>.</p>
<p >For MacOS and Linux, open Terminal and type <code>ls /dev/tty*</code> for a list of connected devices. The programmer will look something like <code>/dev/tty.usbmodem141201</code>.</p>
<p >For Windows, it will look something like COM3.</p>
<p >In Terminal/cmd, type <code>avrdude</code> to check the AVRDUDE software has been correctly installed. It should give you a helpful list of options you can use.</p>
<p >Now we can check the programmer and target MCU are connected and being recognised correctly by typing something along the lines of: </p><div class="fragment"><div class="line">avrdude -p m328p -b 19200 -c avrisp -P /dev/tty.usbmodem141201</div>
</div><!-- fragment --><p> But replace <code>m328p</code> with your MCU type, <code>19200</code> with the baud rate of your serial programmer, <code>avrisp</code> with your programmer type and <code>/dev/tty.usbmodem141201</code> with the port address your programmer is connected to if different from these.</p>
<p >You should then see a success message like the one below. If not, check your wiring and connections, check the target MCU is powered, and check the programmer type, baud rate and AVR chip type are correct.</p>
<div class="image">
<img src="avrdude-interrogate-success.png" alt=""/>
<div class="caption">
AVRDUDE success message</div></div>
    <h1><a class="anchor" id="autotoc_md23"></a>
Configuring the Makefile</h1>
<p >The Makefile is there to make your life easier. Instead of having to type out commands and options along with files and dependancies each time you want to build and flash your application, you can just define some variables in a Makefile, then all you have to do is type <code>make</code> to build your application.</p>
<p >Download the <a href="https://github.com/Jason-Duffy/AVRly/tree/main/content/getting-started/source" target="_blank">source</a> folder in this repository and open up the Makefile. The following variables need to be edited for your setup.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
MCU, Programmer and Directory variables</h2>
<h3><a class="anchor" id="autotoc_md25"></a>
MCU</h3>
<p >This is the AVR chip type, a list of valid names can be found <a href="https://www.nongnu.org/avrdude/user-manual/avrdude_3.html" target="_blank">here</a>.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
F_CPU</h3>
<p >This is the clock speed in Hz - Note the UL assignment (Unsigned Long). For the examples covered in this repo we will be using the 8MHz internal oscillator as a clock source for simplicity, though you can use an external clock source upto 20MHz if you'd prefer. By default, the AVR fuses will be set to divide the internal clock speed by 8 (resulting in a speed of 1MHz) but we will override that with some Makefile settings.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
BAUD</h3>
<p >This is the baud rate used for serial comms with the AVR, usually 9600 but sometimes differs.</p>
<h3><a class="anchor" id="autotoc_md28"></a>
LIBDIR</h3>
<p >A directory for common include files, some of which are installed with the AVR toolchain.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
PROGRAMMER_TYPE</h3>
<p >The type of ISP programmer you're using. A list of valid names can be found <a href="https://www.nongnu.org/avrdude/user-manual/avrdude_3.html" target="_blank">here</a>.</p>
<h3><a class="anchor" id="autotoc_md30"></a>
PROGRAMMER_ARGS</h3>
<p >Extra arguments to avrdude: baud rate, chip type, -F flag, etc. This baud rate is for serial comms to the programmer. The port address also goes here.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Fuses</h2>
<p ><b>WARNING</b> Take great care when editing these variables, they can brick the MCU if set incorrectly. Always refer to the <a href="https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf" target="_blank">datasheet</a> if unsure, especially if you are using a different MCU to the ATmega328p. And note that they use an inverse logic - the bit will read 1 if unprogrammed, and 0 if programmed. A handy fuse setting calculator can be found <a href="https://www.engbedded.com/fusecalc/" target="_blank">here</a>.</p>
<h3><a class="anchor" id="autotoc_md32"></a>
Default Fuse Values</h3>
<p >The default fuse values in the Makefile have been set to work with the following MCUs:</p>
<ul>
<li>ATmega48</li>
<li>ATmega88</li>
<li>ATmega168</li>
<li>ATmega328</li>
</ul>
<p >If you are using a different MCU, check the default fuse values <a href="https://www.engbedded.com/fusecalc/" target="_blank">here</a>, then change the value of these variables.</p>
<h4><a class="anchor" id="autotoc_md33"></a>
LFUSE</h4>
<p >Low fuse byte. This is used to select the clock source and some config settings for clock operation. The default value in hexadecimal format is 0x62.</p>
<h4><a class="anchor" id="autotoc_md34"></a>
HFUSE</h4>
<p >High fuse byte. This is used for bootloader memory allocation, EEPROM, watchdog timer, programming and reset options. The default value is 0xD9.</p>
<h4><a class="anchor" id="autotoc_md35"></a>
EFUSE</h4>
<p >Extended fuse byte. This is used to configure brown-out detection. The default value is 0xFF.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
Custom Fuse Values</h3>
<p >The custom fuse values in the Makefile have been set to use the internal clock source at 8MHz, for the aforementioned MCUs, so you will need to edit these if you have chosen a different MCU. If you want to customise the fuse settings yourself, then edit these custom values, but don't touch the Default fuse values so you can revert them later if needed.</p>
<h4><a class="anchor" id="autotoc_md37"></a>
LFUSE_CUSTOM</h4>
<p >Low fuse byte. This is used to select the clock source and some config settings for clock operation.</p>
<div class="image">
<img src="low_fuse.png" alt=""/>
<div class="caption">
Fuse low byte register (ATmega328P)</div></div>
    <h4><a class="anchor" id="autotoc_md38"></a>
HFUSE_CUSTOM</h4>
<p >High fuse byte. Bits 2 - 0 are used to select the amount of memory allocated for a bootloader (not required for the projects in this collection). The remaining bits are used to control EEPROM, watchdog timer, programming and reset options. SPIEN and RSTDISBL are the dangerous ones likely to brick your MCU if set incorrectly, so <b>only</b> touch these if you know what you're doing.</p>
<div class="image">
<img src="high_fuse.png" alt=""/>
<div class="caption">
Fuse high byte register (ATmega328P)</div></div>
    <h4><a class="anchor" id="autotoc_md39"></a>
EFUSE_CUSTOM</h4>
<p >Extended fuse byte. This is used to set the brownout detection level. "Brown-out" is the term for the power supply voltage dropping to a point which is unsuitable for the MCU to function properly. If BOD (Brown-Out Detection) is enabled, the reset pin will be held low while a brown-out condition is detected. BOD is not required for the projects in this collection.</p>
<div class="image">
<img src="extended_fuse.png" alt=""/>
<div class="caption">
Extended fuse byte register (ATmega328P)</div></div>
    <h1><a class="anchor" id="autotoc_md40"></a>
Make Commands</h1>
<p >With the Makefile correctly configured, you are now ready to start using the commands it defines. Open Terminal and navigate to the directory where you stored the local copy of the <a href="https://github.com/Jason-Duffy/AVRly/tree/main/content/getting-started/source" target="_blank">source</a> folder you downloaded. Type <code>make help</code> to print a list of commands to the terminal - shown below.</p>
<div class="image">
<img src="make_help.png" alt=""/>
<div class="caption">
make help output</div></div>
    <h2><a class="anchor" id="autotoc_md41"></a>
Show Fuses</h2>
<p >To see the fuse values already set on the target MCU, type <code>make show_fuses</code>. Data will be read from the chip and output via the terminal. An example of that output is shown in the image below.</p>
<div class="image">
<img src="show_fuses.png" alt=""/>
<div class="caption">
show_fuses output</div></div>
    <h2><a class="anchor" id="autotoc_md42"></a>
Flash Fuses</h2>
<p >First we need to flash the fuse settings. To do this, type <code>make set_custom_fuses</code> and the custom values from your Makefile will be written to the chip. You only need to do this when a chip is new, in an unknown state (eg. when re-used from a previous project) or you want to change the fuse settings. These new settings will be "burned" into the register and remain even after the chip is powered down. To revert to default fuse values, run <code>make set_default_fuses</code>.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Flash the Code</h2>
<p >Now we are finally ready to flash the code. Type <code>make flash</code>, and the source code will be compiled, linked and written to the MCU.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
Basic Make Commands</h3>
<ul>
<li><code>make</code> to compile the source code based on the settings in your Makefile.</li>
<li><code>make flash</code> to compile and flash the code to the target MCU.</li>
<li><code>make clean</code> to delete the compiled output files from the current directory.</li>
</ul>
<p >These can of course be combined like so: <code>make clean flash</code>, though you do not need to run <code>clean</code> each time - usually <code>make flash</code> works just fine. Output is shown below.</p>
<div class="image">
<img src="make_clean_flash.png" alt=""/>
<div class="caption">
make clean flash output</div></div>
    <h1><a class="anchor" id="autotoc_md45"></a>
Verify Makefile Settings</h1>
<p >You should now have an LED which blinks on and off in a 2 second cycle - 1 second on, followed by 1 second off. If it is blinking considerably faster or slower than this, check that the value of F_CPU and LFUSE are set correctly.</p>
<p >Once you are satisfied that the LED is blinking as it should be, you're ready to proceed to the <a href="https://github.com/Jason-Duffy/AVRly/tree/main/content/modules" target="_blank">more exciting projects and examples</a> in this repo!</p>
<p >If you're ready to start developing using your own source code, some blank template files can be found <a href="https://github.com/Jason-Duffy/AVRly/tree/main/content/modules/templates" target="_blank">here</a>.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Further Reading</h1>
<h2><a class="anchor" id="autotoc_md47"></a>
GNU Make Utility</h2>
<p >If you'd like to learn more about the GNU Make Utility, more information can be found <a href="https://www.gnu.org/software/make/" target="_blank">here</a>. I found it to be a steep learning curve, so if you'd rather not wade into it just yet there are plenty of Makefile generators around. The Makefile used in these projects was adapted from the code provided with the book Make: AVR Programming by Elliot Williams. His repo, <a href="https://github.com/hexagon5un/AVR-Programming" target="_blank">hexagon5un/AVR-Programming</a> has some great example projects, and I would thoroughly recommend the book to anyone looking to get into AVR Programming.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Style &amp; Layout Guide</h2>
<p >For a comprehensive guide on layout, style and documentation, see the <a href="https://jason-duffy.github.io/AVRly/html/md_content_anatomy_of_embedded_firmware__anatomy.html" target="_blank">Anatomy of Embedded Firmware page</a>.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Documentation</h2>
<p >Documentation is provided throughout this site using <a href="https://www.doxygen.nl/index.html" target="_blank">Doxygen</a>. Output of the Doxygen documentation for the Blink project can be found <a href="https://jason-duffy.github.io/AVRly/html/group__getting__started.html" target="_blank">here</a>.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Coding Standards</h2>
<p >Adhering to coding standards helps to make your code more readable, robust, easier to debug and more portable. The firmware in this repo was written to the <a href="https://barrgroup.com/sites/default/files/barr_c_coding_standard_2018.pdf" target="_blank">Barr Group C Coding Standard</a>, and I would encourage others to read it and use those guidelines in their own code. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
